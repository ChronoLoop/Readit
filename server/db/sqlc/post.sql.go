// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: post.sql

package dbconnection

import (
	"context"
	"database/sql"
	"time"
)

const createPost = `-- name: CreatePost :exec
INSERT INTO posts (
    user_id,
    subreadit_id,
    title,
    text
) VALUES (
    $1, $2, $3, $4
)
`

type CreatePostParams struct {
	UserID      int64  `json:"user_id"`
	SubreaditID int64  `json:"subreadit_id"`
	Title       string `json:"title"`
	Text        string `json:"text"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) error {
	_, err := q.db.ExecContext(ctx, createPost,
		arg.UserID,
		arg.SubreaditID,
		arg.Title,
		arg.Text,
	)
	return err
}

const createUserReadPost = `-- name: CreateUserReadPost :exec
INSERT INTO user_read_posts (
    user_id,
    post_id
) 
VALUES (
    $1, $2
)
`

type CreateUserReadPostParams struct {
	UserID int64 `json:"user_id"`
	PostID int64 `json:"post_id"`
}

func (q *Queries) CreateUserReadPost(ctx context.Context, arg CreateUserReadPostParams) error {
	_, err := q.db.ExecContext(ctx, createUserReadPost, arg.UserID, arg.PostID)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE
FROM posts
WHERE id = $1 AND user_id = $2
`

type DeletePostParams struct {
	ID     int64 `json:"id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) DeletePost(ctx context.Context, arg DeletePostParams) error {
	_, err := q.db.ExecContext(ctx, deletePost, arg.ID, arg.UserID)
	return err
}

const findPostById = `-- name: FindPostById :one
SELECT users.created_at, users.updated_at, users.deleted_at, users.id, users.username, users.password, subreadits.created_at, subreadits.updated_at, subreadits.deleted_at, subreadits.id, subreadits.name, posts.created_at, posts.updated_at, posts.deleted_at, posts.id, posts.title, posts.user_id, posts.subreadit_id, posts.text
FROM posts
LEFT JOIN users ON posts.user_id = users.id
LEFT JOIN subreadits ON posts.subreadit_id = subreadits.id
WHERE posts.id = $1 LIMIT 1
`

type FindPostByIdRow struct {
	User        User         `json:"user"`
	Subreadit   Subreadit    `json:"subreadit"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	ID          int64        `json:"id"`
	Title       string       `json:"title"`
	UserID      int64        `json:"user_id"`
	SubreaditID int64        `json:"subreadit_id"`
	Text        string       `json:"text"`
}

func (q *Queries) FindPostById(ctx context.Context, id int64) (FindPostByIdRow, error) {
	row := q.db.QueryRowContext(ctx, findPostById, id)
	var i FindPostByIdRow
	err := row.Scan(
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.DeletedAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.Password,
		&i.Subreadit.CreatedAt,
		&i.Subreadit.UpdatedAt,
		&i.Subreadit.DeletedAt,
		&i.Subreadit.ID,
		&i.Subreadit.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID,
		&i.Title,
		&i.UserID,
		&i.SubreaditID,
		&i.Text,
	)
	return i, err
}

const getPosts = `-- name: GetPosts :many
SELECT users.created_at, users.updated_at, users.deleted_at, users.id, users.username, users.password, subreadits.created_at, subreadits.updated_at, subreadits.deleted_at, subreadits.id, subreadits.name, posts.created_at, posts.updated_at, posts.deleted_at, posts.id, posts.title, posts.user_id, posts.subreadit_id, posts.text
FROM posts
LEFT JOIN users ON posts.user_id = users.id
LEFT JOIN subreadits ON posts.subreadit_id = subreadits.id
ORDER BY posts.created_at DESC
`

type GetPostsRow struct {
	User        User         `json:"user"`
	Subreadit   Subreadit    `json:"subreadit"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	ID          int64        `json:"id"`
	Title       string       `json:"title"`
	UserID      int64        `json:"user_id"`
	SubreaditID int64        `json:"subreadit_id"`
	Text        string       `json:"text"`
}

func (q *Queries) GetPosts(ctx context.Context) ([]GetPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsRow{}
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Password,
			&i.Subreadit.CreatedAt,
			&i.Subreadit.UpdatedAt,
			&i.Subreadit.DeletedAt,
			&i.Subreadit.ID,
			&i.Subreadit.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.SubreaditID,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsBySubreaditId = `-- name: GetPostsBySubreaditId :many
SELECT users.created_at, users.updated_at, users.deleted_at, users.id, users.username, users.password, subreadits.created_at, subreadits.updated_at, subreadits.deleted_at, subreadits.id, subreadits.name, posts.created_at, posts.updated_at, posts.deleted_at, posts.id, posts.title, posts.user_id, posts.subreadit_id, posts.text
FROM posts
LEFT JOIN users ON posts.user_id = users.id
LEFT JOIN subreadits ON posts.subreadit_id = subreadits.id
WHERE subreadit_id = $1
ORDER BY posts.created_at DESC
`

type GetPostsBySubreaditIdRow struct {
	User        User         `json:"user"`
	Subreadit   Subreadit    `json:"subreadit"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	ID          int64        `json:"id"`
	Title       string       `json:"title"`
	UserID      int64        `json:"user_id"`
	SubreaditID int64        `json:"subreadit_id"`
	Text        string       `json:"text"`
}

func (q *Queries) GetPostsBySubreaditId(ctx context.Context, subreaditID int64) ([]GetPostsBySubreaditIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsBySubreaditId, subreaditID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsBySubreaditIdRow{}
	for rows.Next() {
		var i GetPostsBySubreaditIdRow
		if err := rows.Scan(
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Password,
			&i.Subreadit.CreatedAt,
			&i.Subreadit.UpdatedAt,
			&i.Subreadit.DeletedAt,
			&i.Subreadit.ID,
			&i.Subreadit.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.SubreaditID,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsBySubreaditName = `-- name: GetPostsBySubreaditName :many
SELECT users.created_at, users.updated_at, users.deleted_at, users.id, users.username, users.password, subreadits.created_at, subreadits.updated_at, subreadits.deleted_at, subreadits.id, subreadits.name, posts.created_at, posts.updated_at, posts.deleted_at, posts.id, posts.title, posts.user_id, posts.subreadit_id, posts.text
FROM posts
LEFT JOIN users ON posts.user_id = users.id
LEFT JOIN subreadits ON posts.subreadit_id = subreadits.id
WHERE subreadits.name = $1
ORDER BY posts.created_at DESC
`

type GetPostsBySubreaditNameRow struct {
	User        User         `json:"user"`
	Subreadit   Subreadit    `json:"subreadit"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	DeletedAt   sql.NullTime `json:"deleted_at"`
	ID          int64        `json:"id"`
	Title       string       `json:"title"`
	UserID      int64        `json:"user_id"`
	SubreaditID int64        `json:"subreadit_id"`
	Text        string       `json:"text"`
}

func (q *Queries) GetPostsBySubreaditName(ctx context.Context, name string) ([]GetPostsBySubreaditNameRow, error) {
	rows, err := q.db.QueryContext(ctx, getPostsBySubreaditName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPostsBySubreaditNameRow{}
	for rows.Next() {
		var i GetPostsBySubreaditNameRow
		if err := rows.Scan(
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Password,
			&i.Subreadit.CreatedAt,
			&i.Subreadit.UpdatedAt,
			&i.Subreadit.DeletedAt,
			&i.Subreadit.ID,
			&i.Subreadit.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID,
			&i.Title,
			&i.UserID,
			&i.SubreaditID,
			&i.Text,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserReadPost = `-- name: GetUserReadPost :one
SELECT created_at, updated_at, deleted_at, user_id, post_id, read_at
FROM user_read_posts
WHERE post_id = $1 AND user_id = $2 LIMIT 1
`

type GetUserReadPostParams struct {
	PostID int64 `json:"post_id"`
	UserID int64 `json:"user_id"`
}

func (q *Queries) GetUserReadPost(ctx context.Context, arg GetUserReadPostParams) (UserReadPost, error) {
	row := q.db.QueryRowContext(ctx, getUserReadPost, arg.PostID, arg.UserID)
	var i UserReadPost
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.PostID,
		&i.ReadAt,
	)
	return i, err
}
