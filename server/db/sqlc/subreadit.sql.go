// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: subreadit.sql

package dbconnection

import (
	"context"
)

const createSubreadit = `-- name: CreateSubreadit :one
INSERT INTO subreadits (
    name
) VALUES (
    $1
) RETURNING created_at, updated_at, deleted_at, id, name
`

func (q *Queries) CreateSubreadit(ctx context.Context, name string) (Subreadit, error) {
	row := q.db.QueryRowContext(ctx, createSubreadit, name)
	var i Subreadit
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID,
		&i.Name,
	)
	return i, err
}

const findSubreaditById = `-- name: FindSubreaditById :one
SELECT created_at, updated_at, deleted_at, id, name FROM subreadits
WHERE id = $1 LIMIT 1
`

func (q *Queries) FindSubreaditById(ctx context.Context, id int64) (Subreadit, error) {
	row := q.db.QueryRowContext(ctx, findSubreaditById, id)
	var i Subreadit
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID,
		&i.Name,
	)
	return i, err
}

const findSubreaditByName = `-- name: FindSubreaditByName :one
SELECT created_at, updated_at, deleted_at, id, name FROM subreadits
WHERE name = $1 LIMIT 1
`

func (q *Queries) FindSubreaditByName(ctx context.Context, name string) (Subreadit, error) {
	row := q.db.QueryRowContext(ctx, findSubreaditByName, name)
	var i Subreadit
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ID,
		&i.Name,
	)
	return i, err
}

const findSubreaditUser = `-- name: FindSubreaditUser :one
SELECT users.created_at, users.updated_at, users.deleted_at, users.id, users.username, users.password, subreadits.created_at, subreadits.updated_at, subreadits.deleted_at, subreadits.id, subreadits.name, subreadit_users.subreadit_id, subreadit_users.user_id, subreadit_users.role
FROM subreadit_users
LEFT JOIN users ON users.id = subreadit_users.user_id
LEFT JOIN subreadits ON subreadits.id = subreadit_users.subreadit_id
WHERE subreadit_id = $1 AND user_id = $2 LIMIT 1
`

type FindSubreaditUserParams struct {
	SubreaditID int64 `json:"subreadit_id"`
	UserID      int64 `json:"user_id"`
}

func (q *Queries) FindSubreaditUser(ctx context.Context, arg FindSubreaditUserParams) (UserSubreaditsRow, error) {
	row := q.db.QueryRowContext(ctx, findSubreaditUser, arg.SubreaditID, arg.UserID)
	var i UserSubreaditsRow
	err := row.Scan(
		&i.User.CreatedAt,
		&i.User.UpdatedAt,
		&i.User.DeletedAt,
		&i.User.ID,
		&i.User.Username,
		&i.User.Password,
		&i.Subreadit.CreatedAt,
		&i.Subreadit.UpdatedAt,
		&i.Subreadit.DeletedAt,
		&i.Subreadit.ID,
		&i.Subreadit.Name,
		&i.SubreaditID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const getSubreaditUsersByRole = `-- name: GetSubreaditUsersByRole :many
SELECT users.created_at, users.updated_at, users.deleted_at, users.id, users.username, users.password, subreadits.created_at, subreadits.updated_at, subreadits.deleted_at, subreadits.id, subreadits.name, subreadit_users.subreadit_id, subreadit_users.user_id, subreadit_users.role
FROM subreadit_users
LEFT JOIN users ON users.id = subreadit_users.user_id
LEFT JOIN subreadits ON subreadits.id = subreadit_users.subreadit_id
WHERE subreadit_id = $1 AND role = $2
`

type GetSubreaditUsersByRoleParams struct {
	SubreaditID int64  `json:"subreadit_id"`
	Role        string `json:"role"`
}

func (q *Queries) GetSubreaditUsersByRole(ctx context.Context, arg GetSubreaditUsersByRoleParams) ([]UserSubreaditsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubreaditUsersByRole, arg.SubreaditID, arg.Role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSubreaditsRow{}
	for rows.Next() {
		var i UserSubreaditsRow
		if err := rows.Scan(
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Password,
			&i.Subreadit.CreatedAt,
			&i.Subreadit.UpdatedAt,
			&i.Subreadit.DeletedAt,
			&i.Subreadit.ID,
			&i.Subreadit.Name,
			&i.SubreaditID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubreadits = `-- name: GetSubreadits :many
SELECT created_at, updated_at, deleted_at, id, name FROM subreadits
`

func (q *Queries) GetSubreadits(ctx context.Context) ([]Subreadit, error) {
	rows, err := q.db.QueryContext(ctx, getSubreadits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subreadit{}
	for rows.Next() {
		var i Subreadit
		if err := rows.Scan(
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSubreadits = `-- name: GetUserSubreadits :many
SELECT users.created_at, users.updated_at, users.deleted_at, users.id, users.username, users.password, subreadits.created_at, subreadits.updated_at, subreadits.deleted_at, subreadits.id, subreadits.name, subreadit_users.subreadit_id, subreadit_users.user_id, subreadit_users.role
FROM subreadit_users
LEFT JOIN users ON users.id = subreadit_users.user_id
LEFT JOIN subreadits ON subreadits.id = subreadit_users.subreadit_id
WHERE subreadit_users.user_id = $1
`

type UserSubreaditsRow struct {
	User        User      `json:"user"`
	Subreadit   Subreadit `json:"subreadit"`
	SubreaditID int64     `json:"subreadit_id"`
	UserID      int64     `json:"user_id"`
	Role        string    `json:"role"`
}

func (q *Queries) GetUserSubreadits(ctx context.Context, userID int64) ([]UserSubreaditsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserSubreadits, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSubreaditsRow{}
	for rows.Next() {
		var i UserSubreaditsRow
		if err := rows.Scan(
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.ID,
			&i.User.Username,
			&i.User.Password,
			&i.Subreadit.CreatedAt,
			&i.Subreadit.UpdatedAt,
			&i.Subreadit.DeletedAt,
			&i.Subreadit.ID,
			&i.Subreadit.Name,
			&i.SubreaditID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinSubreadit = `-- name: JoinSubreadit :exec
INSERT INTO subreadit_users (
    subreadit_id,
    user_id,
    role
) VALUES (
    $1,
    $2,
    $3
)
`

type JoinSubreaditParams struct {
	SubreaditID int64  `json:"subreadit_id"`
	UserID      int64  `json:"user_id"`
	Role        string `json:"role"`
}

func (q *Queries) JoinSubreadit(ctx context.Context, arg JoinSubreaditParams) error {
	_, err := q.db.ExecContext(ctx, joinSubreadit, arg.SubreaditID, arg.UserID, arg.Role)
	return err
}

const leaveSubreadit = `-- name: LeaveSubreadit :exec
DELETE FROM subreadit_users
WHERE subreadit_id = $1 AND user_id = $2
`

type LeaveSubreaditParams struct {
	SubreaditID int64 `json:"subreadit_id"`
	UserID      int64 `json:"user_id"`
}

func (q *Queries) LeaveSubreadit(ctx context.Context, arg LeaveSubreaditParams) error {
	_, err := q.db.ExecContext(ctx, leaveSubreadit, arg.SubreaditID, arg.UserID)
	return err
}
